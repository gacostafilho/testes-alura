# -*- coding: utf-8 -*-
"""Formação Data Science Alura - Análise exploratória do MovieLens.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qIX_RsDEK5t46eBSXrwxvsmF8XO1k_7p

Graciliano Alves da Costa Filho

---
Descobertas: 

Apesar de os filmes de ação e os de aventura terem muitas avaliações e muitos filmes, a popularidade média dos filmes de guerra é maior do que a desses dois gêneros.

A nota média dos filmes do género animation, parece aumentar para filmes lançados mais recentemente ao contrário da nota média de todos os gêneros agregados.

## Formação Data Science Alura - Análise exploratória do MovieLens

Na formação de Data Scienda www.alura.com.br um dos conjuntos de dados que utilizamos é o de avaliações para filmes no site MovieLens. Neste projeto faremos uma análise exploratória desses dados.

### Dicas para o projeto completo:

- todo gráfico deve ter um título, labels e legendas que fazem sentido
- configure um tamanho adequado para os gráficos
- utilize as versões dos arquivos de dados disponíveis no github

## Pergunta: conferindo as versões utilizadas

- Devemos usar pandas 0.24.0 ou mais recente
- Devemos usar seaborn 0.9.0 ou mais recente
- Devemos usar scipy 1.2.0 ou mais recente
"""

!pip install pandas=="0.24.0" --quiet
!pip install seaborn=="0.9.0" --quiet
!pip install scipy=="1.2.0" --quiet

import pandas as pd
import seaborn as sns
import scipy

print("Usando pandas %s" % pd.__version__)
print("Usando seaborn %s" % sns.__version__)
print("Usando scipy %s" % scipy.__version__)

"""## Pergunta: carregue os filmes

- os dados `https://raw.githubusercontent.com/alura-cursos/formacao-data-science/master/movies.csv` devem ser carregado em `filmes`
- renomeie as colunas para `filmeId`, `titulo` e `generos`
- configure o indice (`index`) para ser o `filmeId`
"""

# solução
url = "https://raw.githubusercontent.com/alura-cursos/formacao-data-science/master/movies.csv"
filmes = pd.read_csv(url)
filmes.columns = ['filmeId', 'titulo', 'generos']
filmes.set_index('filmeId', inplace=True)

filmes.head()

print("Carregamos %d filmes" % len(filmes))
if(len(filmes) != 9742):
    print("ERRO! O conjunto de dados que estamos trabalhando nesse projeto possui 9742 elementos.")

"""Vamos extrair o ano dos filmes (código já pronto):"""

ano_de_lancamento = filmes.titulo.str.extract("\((\d{4})\)")
filmes['ano_de_lancamento'] = ano_de_lancamento.astype(float)
filmes.head()

"""## Pergunta: carregando as notas

- os dados `https://raw.githubusercontent.com/alura-cursos/formacao-data-science/master/ratings.csv` devem ser carregado em `notas`
- renomeie as colunas para `usuarioId`, `filmeId`, `nota` e `momento`
"""

# solução
url = "https://raw.githubusercontent.com/alura-cursos/formacao-data-science/master/ratings.csv"
notas = pd.read_csv(url)
notas.columns = ['usuarioId', 'filmeId', 'nota', 'momento']

notas.head()

"""## Pergunta: gere uma nova feature, a média dos votos por filme

- crie uma nova coluna chamada `nota_media` dentro do dataframe `filmes`

Dicas:
- como filmeId já é o indice de seu dataframe filmes, se você possui uma série com o número de votos por filme, basta atribuir uma nova coluna normalmente que será usado o mesmo índice
"""

# solução
filmes['nota_media'] = notas.groupby('filmeId').mean()['nota']

filmes.head(10)

"""## Pergunta: remova os filmes com menos de 50 avaliações

- conte o número de notas por filme
- adicione uma coluna nova chamada `total_de_votos` a `filmes` que representa o número de avaliações que aquele filme teve no conjunto de dados
- remova os que tem 49 ou menos de `filmes`

## Solução
"""

# solução para calcular o total de votos por filme
contagem = notas.groupby('filmeId').count()['nota']

# solução para criar a nova coluna e filtrar os filmes
filmes['total_de_votos'] = contagem
filmes.query('total_de_votos >= 50', inplace=True)

filmes.head(10)

"""# Visualizando os dados gerais

## Pergunta: Visualize as notas médias

- histograma
- cummulative distribution function

Dicas:

- lembre-se de colocar um título nas imagens além de nomes nos eixos x e y
- para gerar a versão cumulativa lembre-se de usar os parâmetros `hist_kws` e `kde_kws` para definir `'cumulative'=True`
"""

# solução histograma
sns.set_style("white")
ax = sns.distplot(filmes['nota_media'], kde = False)
ax.figure.set_size_inches(12,6)
ax.set(xlabel="Nota média", ylabel="Frequência")
ax.set_title('Distribuição notas médias')

# solução cumulativa
ax = sns.distplot(filmes['nota_media'], hist_kws={'cumulative':True}, kde_kws={'cumulative':True})
ax.figure.set_size_inches(12,6)
ax.set(xlabel="Nota média", ylabel="Frequência")
ax.set_title('Distribuição notas médias')

"""## Pergunta: Visualize o total de votos

- histograma
- cummulative distribution function
"""

# solução histograma
ax = sns.distplot(filmes['total_de_votos'])
ax.figure.set_size_inches(12,6)
ax.set(xlabel="Total de votos", ylabel="Frequência")
ax.set_title('Distribuição de votos')

# solução cumulativa
ax = sns.distplot(filmes['total_de_votos'], hist_kws={'cumulative':True}, kde_kws={'cumulative':True})
ax.figure.set_size_inches(12,6)
ax.set(xlabel="Total de votos", ylabel="Frequência")
ax.set_title('Distribuição de votos')

"""## Pergunta: 20% dos filmes do dataframe tem nota maior que? 

- lembre-se da função `quantile` do pandas
"""

# solução
nota_limite_dos_20_porcento = filmes.nota_media.quantile(0.8)

print("20 porcento dos filmes tem nota maior que de %.2f" % nota_limite_dos_20_porcento)

"""## Vamos separar a coluna `generos` em diversas colunas.

- O código já está pronto.
"""

filmes['generos'] = filmes['generos'].str.replace('-', '')
generos = filmes['generos'].str.get_dummies()
print("Temos %d generos distintos" % generos.shape[1])

filmes = filmes.join(generos).drop(columns=['generos'], axis=1)
filmes.head()

"""## Pergunta: visualização de quantos filmes existem por genero

- Para cada um dos generos você deve agrupar o número de filmes
- Ordene as barras, na esquerda o genero com mais filmes, na direita o que tem menos filmes

Dica:

- Para fazer a soma de uma ou mais colunas individualmente você pode usar `seu_dataframe.sum()`
- Não precisa usar o dataframe `filmes`, somente o dataframe `generos`
- Em certas situações é mais fácil usar as funções de plotagem do pandas ao invés do seaborn
"""

# solução
generos_ordenados = generos.sum().sort_values(ascending = False)
ax = generos_ordenados.plot.bar(figsize=(12,6), title='N° de filmes por gênero')
ax.set_xlabel("Gêneros")
ax.set_ylabel("N° de filmes")
ax

"""## Pergunta: Quais são os 5 generos com mais filmes?

Dica:

- `sort_values()` pode ordenar uma Series do pandas
"""

# solução
top5_generos_em_quantidade_de_filmes = generos.sum().sort_values(ascending = False)

print(top5_generos_em_quantidade_de_filmes)

"""## Pergunta: visualização de votos por genero

- o código que gera os votos por genero já está pronto
- ordene as categorias da mais visualizada para a menos visualizada
- gere a visualização por genero
"""

votos_por_genero_por_filme = pd.DataFrame((generos.values.T * filmes['total_de_votos'].values).T, columns = generos.columns)
votos_por_genero_por_filme.head(10)

# solucão
generos_mais_visualizados = votos_por_genero_por_filme.sum().sort_values(ascending=False)
generos_mais_visualizados

# solução
ax = generos_mais_visualizados.plot.bar(figsize=(12,6), title='N° de visualizações por gênero')
ax.set_xlabel("Gêneros")
ax.set_ylabel("N° de visualizações")
ax

"""## Pergunta : votos por filme por genero

Queremos entender a quantidade de votos em relação a quantidade de filmes existentes naquele genero.

Por exemplo: 
- se temos 1000 votos de `Ação` e 10 filmes desse genero, foram 100 votos por filme nesse genero.
- se o gênero `Documentário` tem 2 filmes e 500 votos, ele tem 250 votos por filme nesse gênero.

Queremos entender isso, a "popularidade" média de um filme em cada categoria, isto é, o número de votos dividido pelo número de filmes, organizado para cada categoria.

- Você já possui o número de votos por genero
- Calcule o número de votos por genero dividido pelo total de filmes por genero
- Ordene do maior para o menor
- Plote um gráfico para visualizarmos esses dados
"""

# solucao código
popularidade_media_por_genero = (votos_por_genero_por_filme.sum()/generos.sum()).sort_values(ascending=False)
popularidade_media_por_genero

# solução com visualização 
ax = popularidade_media_por_genero.plot.bar(figsize=(12,6), title='Popularidade média por gênero')
ax.set_xlabel("Gêneros")
ax.set_ylabel("Popularidade")
ax

"""## Pergunta: Olhando as 3 últimas visualizações o que você conclui sobre os generos `Action` e `War`?

### Solução (texto livre):
Existem muitos filmes de ação com muitas visualizações no total. Existem poucos filmes de guerra com pouca visualização no total. Porém cada filme de guerra é mais popular do que os de ação, ou seja tem uma média de visualização maior.

## Pergunta: Crie 2 boxplots no mesmo plot comparando a coluna `total_de_votos` dos filmes de categoria `Horror` e `Adventure`  

Dica:

- as vezes é mais fácil usar o boxplot do matplotlib ao invés do seaborn
- plt.boxplot suporta o parâmetro labels com uma lista de nomes para cada boxplot plotado
"""

# solução:
import matplotlib.pyplot as plt

filmes_aventura = filmes.query("Adventure == 1")
filmes_horror = filmes.query("Horror == 1")
plt.figure(figsize=(12,6))
plt.title("Comparação de votos entre Adventure e Horror")
plt.ylabel("N° de votos")
plt.boxplot([filmes_aventura['total_de_votos'], filmes_horror['total_de_votos']], labels=["Adventure","Horror"])

"""## Pergunta: mostre agora um boxplot para cada uma das categorias

Dica:
- use generos.columns para acessar todos os gêneros
- já removemos os hífens dos nomes das colunas quando criamos as colunas de gêneros
- plt (pyplot) do matplotlib suporta a função xticks(rotation=90) para rotacionar os labels
"""

ax = votos_por_genero_por_filme.boxplot(figsize=(20,10))
ax.set_xlabel("Gêneros")
ax.set_ylabel("N° de votos por filme")

"""## Pergunta: desejo criar um filme com somente um dos gêneros: `Horror` ou `Adventure`. Quero ter uma chance maior de ter um faturamento que pague minhas contas, mesmo que não seja um super sucesso absurdo de vendas. Qual dos 2 gêneros você sugere?

### Solução:
Sugiro fazer um filme com o gênero Adventure, pois olhando no boxplot de votos a mediana dos filmes adventure é bem mais alta do que as horror. O 3° quartil é bem mais alto também.
Assim um filme do tipo adventure tem bem mais chance de ser mais popular do que um do tipo Horror.

## Pergunta: nossa análise foi até então visual. Aplique um teste estatístico para verificar se existe significância estatística na distribuição dos votos dos filmes de `Adventure` e `Horror`. Sua recomendação continua a mesma? Explique.

Passos:

- visualize a distribuição de ambas através de histogramas
- se suspeitar normalidade na distribuição, faça um teste de normalidade para ambas
- aplique um teste adequado de comparação das distribuições
- explique o resultado encontrado
- utilize p=0.05
"""

# solucao histograma de aventura
ax = sns.distplot(filmes_aventura['total_de_votos'], kde = True)
ax.figure.set_size_inches(12,6)
ax.set(xlabel="Votos", ylabel="Densidade")
ax.set_title('Distribuição de votos de filmes Adventure')

# solucao histograma de horror
ax = sns.distplot(filmes_horror['total_de_votos'], kde = True)
ax.figure.set_size_inches(12,6)
ax.set(xlabel="Votos", ylabel="Densidade")
ax.set_title('Distribuição de votos de filmes Adventure')

# solucao teste de normalidade ou justificativa para nao utiliza-lo
from statsmodels.stats.weightstats import zconfint, ztest
from statsmodels.stats.weightstats import DescrStatsW
from scipy.stats import normaltest

_, p_adventure = normaltest(filmes_aventura['total_de_votos'])
_, p_horror = normaltest(filmes_aventura['total_de_votos'])

print('p_value filmes adventure: {}'.format(p_adventure.round(4)))
if p_adventure < 0.05:
  print('Filmes adventure vem de uma distribuição normal')

print('p_value filmes adventure: {}'.format(p_horror.round(4)))
if p_horror < 0.05:
  print('Filmes horror vem de uma distribuição normal')

# solução com o teste desejado
print(filmes_aventura.shape[0], filmes_horror.index.shape[0])

"""Como filmes horror possui poucas amostras (26) o teste mais adequado é o t-test."""

desc_filmes_aventura = DescrStatsW(filmes_aventura.total_de_votos)
desc_filmes_horror = DescrStatsW(filmes_horror.total_de_votos)

desc_filmes_aventura.get_compare(desc_filmes_horror).summary(use_t=True)

"""### Solução (explique sua conclusão):
Não é possível dizer qual dos filmes teria mais chance de sucesso, pois o p_value (>> 0.05) do teste indica que a diferença entre as distriuições não é significativa. Além disso, observando o intervalo de diferença os filmes de aventura pode ser mais populares, ou menos populares dependendo do caso.

## Pergunta: Faça os mesmos boxplots para as notas médias (`nota_media`) dos gêneros `Adventure` e `Horror`.
"""

# solução:
plt.figure(figsize=(12,6))
plt.title("Comparação das médias entre Adventure e Horror")
plt.ylabel("Nota média")
plt.boxplot([filmes_aventura['nota_media'], filmes_horror['nota_media']], labels=["Adventure","Horror"])

"""## Pergunta: Quero fazer um filme que seja sucesso de crítica, com pessoas dando notas altas, mesmo que não tenha um número muito grande de pessoas assistindo. Qual gênero você recomenda se tenho que escolher somente um entre `Adventure` e `Horror`?

### Solução: observando somente o boxplot não é possível afirmar qual gênero teria melhor crítica, pois são bem parecidos, apesar de os quartis do gênero horror parecer levemente maiores.

## Pergunta: nossa análise foi até então visual. Aplique um teste estatístico para verificar se existe significância estatística na distribuição das notas dos filmes de `Adventure` e `Horror`.

Passos:

- visualize a distribuição de ambas através de histogramas
- se suspeitar normalidade na distribuição, faça um teste de normalidade para ambas
- aplique um teste adequado de comparação das distribuições
- explique o resultado encontrado
- utilize p=0.05
"""

# solucao histograma de aventura
ax = sns.distplot(filmes_aventura['nota_media'], kde = True)
ax.figure.set_size_inches(12,6)
ax.set(xlabel="Nota média", ylabel="Densidade")
ax.set_title('Distribuição de nota media de filmes Adventure')

# solucao histograma de horror
ax = sns.distplot(filmes_horror['nota_media'], kde = True)
ax.figure.set_size_inches(12,6)
ax.set(xlabel="Nota média", ylabel="Densidade")
ax.set_title('Distribuição de média de filmes Horror')

# solução com o teste desejado
_, p_adventure = normaltest(filmes_aventura['nota_media'])
_, p_horror = normaltest(filmes_aventura['nota_media'])

print('p_value filmes adventure: {}'.format(p_adventure.round(4)))
if p_adventure < 0.05:
  print('A distribuição da nota média para filmes adventure vem de uma distribuição normal')

print('p_value filmes adventure: {}'.format(p_horror.round(4)))
if p_horror < 0.05:
  print('A distribuição da nota média para filmes horror vem de uma distribuição normal')

desc_filmes_aventura = DescrStatsW(filmes_aventura.nota_media)
desc_filmes_horror = DescrStatsW(filmes_horror.nota_media)
desc_filmes_aventura.get_compare(desc_filmes_horror).summary(use_t=True)

"""## Sua recomendação para maior sucesso de crítica em nota alta entre `Horror` e `Adventure` continua a mesma? Explique.

### Solução: Sim, continuo com a mesmo opinião. O t-test só confirma que não é possível indicar qual gênero teria a melhor crítica, pois os p_values não tem significância.

## Pergunta: Quero fazer um filme que seja primeiro sucesso de crítica, com pessoas dando notas altas. Em segundo lugar quero que seja popular (mais pessoas assistam). Com as informações visuais e estatísticas, supondo poder escolher somente um, qual dois 2 gêneros você recomenda agora? `Horror` ou `Adventure`?

### Solução: os testes estatísticos para o número de votos e para nota média mostram que não há diferença significativa entre esses gêneros. O teste visual para nota média também não mostra tanta diferença. Resta somente o teste visual para o número de votos, aonde o gênero adventure aparenta ser mais popular do que o outro gênero. Assim eu recomendaria o gênero Adventure.

## Pergunta: Quais são os top 5 filmes dos 2 generos mais assistidas?

- utilize os 2 generos mais votados em `votos_por_genero`
- utilize a `nota_media` para definir o top 5 filmes
- o resultado são 5, não 10 filmes
"""

votos_por_genero_por_filme.sum()

# solução: calculando os 2 generos mais votados
#os filmes mais votados são ação e aventura
filmes_acao = filmes.query('Action == 1')
#já exista Df para os filmes de aventura
filmes_aventura.head()

# solução: encontrando os top 5 filmes desses generos
top5_filmes_acao = filmes_acao.sort_values(by=['nota_media'], ascending=False).head()
top5_filmes_acao

top5_filmes_aventura = filmes_aventura.sort_values(by=['nota_media'], ascending=False).head()
top5_filmes_aventura

"""## Pergunta: Quais são os 2 generos com maior valor de correlação com a `nota_media`? E os 2 com menor valor de correlação com a `nota_media`?

- O pandas possui a função `corr` para calcular correlação entre todas as colunas
"""

# solucao
matriz_correl = filmes.corr()
matriz_correl.sort_values(by=['nota_media'], ascending=False)

"""gênero com maior correlação com nota_media: Drama e Crime.

---

gêneros com menor correlação: Comedy e Action

## Pergunta: Quais são os 2 generos com maior valor de correlação com `total_de_votos`? E quais os 2 com menor valor de correlação com `total_de_votos`?
"""

# solucao
matriz_correl.sort_values(by=['total_de_votos'], ascending=False)

"""gênero com maior correlação com total_de_votos: Adventure e War.

---

gêneros com menor correlação: Comedy e Western

## Pergunta: Visualize graficamente o relacionamento entre ano de lançamento e nota média

- Use o gráfico `lineplot`
"""

# solucao
ax = sns.lineplot(x='ano_de_lancamento', y='nota_media', data=filmes)
ax.figure.set_size_inches(12,6)
ax.set(xlabel="Nota Media", ylabel="Ano de lançamento")
ax.set_title('Relação entre Ano de lançamento e nota média dos filmes')

"""## Pergunta: Interprete a correlação entre `ano_de_lancamento` e a `nota_media`?

- Calcule a correlação numericamente (use o `corr` do pandas)
- Correlação não implica causalidade, qual "problema" na coleta dos dados pode gerar esse tipo de correlação?
"""

# solução (código)
filmes.corr()

filmes.query('ano_de_lancamento <= 1970').mean()['total_de_votos']

filmes.query('ano_de_lancamento > 1970').mean()['total_de_votos']

"""### Solução (explicação): O gráfico e o coeficiente sugerem um correlação negativa entre ano de lançamento e nota média dos filmes. Ou seja, sugere que a média dos filmes mais novos tede a ser mais baixa do que os mais antigos. Um problema que pode causar esse tipo de correlação é existir menos votos para os filmes mais antigos, o que poderia elevar a média deles.

## Pergunta: analise um pairplot

- crie uma variável chamada `infos` baseada nas colunas `ano_de_lancamento`, `nota_media` e `total_de_votos` de `filmes`
- faça o pairplot usando seaborn
- coloque uma regressão linear para cada pequeno plot dentro dele
"""

# solução
infos = ['ano_de_lancamento', 'nota_media', 'total_de_votos']
ax = sns.pairplot(filmes, x_vars=infos, y_vars=infos, kind='reg', height=4)
ax.fig.suptitle("Dispersão entre nota média, total de votos e ano de lançamento", y=1.08)

"""## Pergunta: analise um pairplot dos filmes de `Animation`

- use o dataframe `filmes`
- em um único pairplot separe com cores distintas os filmes da categoria `Animation` dos outros
- use uma palete como `husl`
- use marcadores distintos para cada um dos dois grupos
- faça o pairplot usando seaborn e coloque uma regressão linear para cada pequeno plot dentro dele
- tanto em x quanto y use somente três variáveis: `total_de_votos`, `ano_de_lancamento`, `nota_media`
"""

infos = ['ano_de_lancamento', 'nota_media', 'total_de_votos']
ax = sns.pairplot(filmes, x_vars=infos, y_vars=infos, kind='reg', height=4, hue='Animation', markers=['o','*'], palette = 'husl')
ax.fig.suptitle("Dispersão entre nota média, total de votos e ano de lançamento", y=1.08)

"""## Pergunta: Analise a regressão em relação ao ano de lançamento.

- Como parece se comportar a `nota_media` de filmes de `Animation` mais antigos e mais recentes? (ano_de_lancamento x nota_media). Essa correlação parece ser baixa, mas parece ser linear?
- E o `ano_de_lancamento` x `total_de_votos`?
- E das outras categorias? Compare isso com os outros filmes.
- O que leva você levantar como hipótese para esse resultado?

### Solução:
A nota média para o filmes de animation parece aumentar para filmes mais recentes. A correlação parece linear, apesar de alguns possíveis outliers.

O total de votos parece aumentar em anos mais recentes para os filmes de animation. A correlação parece linear pois não há pontos com notas muitos baixas nos primeiros anos.

A nota média dos demais filmes agrupados parece diminuir com o tempo. É necessário investigar mais a fundo sobre essa correlação para mais conclusões.

Minha hipótese para os filmes do tipo animation é que os efeitos gráficos dos filmes melhoraram ao longo do tempo o que poderia melhorar a avaliação dos filmes.

## Pergunta: Explore

- compartilhe conosco 2 visualizações extras que julgar interessante
- explique o que encontrou
- use quantas células (texto ou código) julgar necessário
"""

# solução

nota_media_usuario = notas.groupby('usuarioId').mean()['nota']
ax = sns.distplot(nota_media_usuario)
ax.figure.set_size_inches(12,6)
ax.set(xlabel="Nota Media", ylabel="Densidade")
ax.set_title('Distribuição das notas médias por usuário')

ax = sns.boxplot(nota_media_usuario)
ax.figure.set_size_inches(12,6)
ax.set(xlabel="Nota Media")
ax.set_title('Boxplot - Distribuição das notas médias por usuário')

_, p_media_usuario = normaltest(nota_media_usuario)
p_media_usuario

"""Conclusão 1: Observando o gráfico de distribuição das notas médias por usuário se assemelha à uma normal. Isso pode ser confirmado pelo normaltest que mostra um p_value bem baixo."""

#a coluna momento representa o tempo em segundos desde meia noite de 01/01/1970
import numpy as np
segundos_ano = 8760*3600
notas['ano_avaliacao'] = (notas['momento']/segundos_ano).apply(np.floor) + 1970
notas.sort_values(by='ano_avaliacao')

nota_media_ano = notas.groupby('ano_avaliacao').mean()['nota']
ax = sns.lineplot(x=nota_media_ano.index, y=nota_media_ano.values, )
ax.figure.set_size_inches(12,6)
ax.set(xlabel="Nota Media", ylabel="Densidade")
ax.set_title('Distribuição das notas médias por usuário')

notas.corr()

"""Conclusão 2: não há correlação entre o ano de avaliação de e as notas médias dos filmes naquele ano. O valor do R² é muito baixo."""